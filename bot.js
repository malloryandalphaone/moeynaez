const Discord = require('discord.js');
const client = new Discord.Client();
var prefix = "!"
const fs = require("fs"); 
const moment = require("moment");  
const ms = require("ms");

client.on("ready", () => {
client.user.setStatus('dnd');
  console.log("Reeebel | Logged in! Server count: ${client.guilds.size}");
  client.user.setGame(`Strict System`);
});


client.on('message', message => {
  const port = '25565'
  if(message.content.startsWith('!stats')) {
 const args = message.content.split(" ").slice(1).join(" ")
    if (!args) return message.channel.send("** Write Server IP . **");
        let embed = new Discord.RichEmbed()
        .setColor('WHITE')
        .setThumbnail(`https://api.minetools.eu/favicon/${args}/25565`)
        .addField("ğŸ“œ Server NIP",`${args}`,true)
        .addField("ğŸŒ Server Port",`${port}`)
        .setImage(`http://status.mclive.eu/${args}/${args}/25565/banner.png`)
        .setFooter(`Server MineCraft Stats`)
    message.channel.send(embed)      
}});




client.on("message", msg => { 
  if(msg.author.bot) return;
  if(msg.channel.type === 'dm') return;
let prefix = '!'; //Ø§Ù„Ø¨Ø±ÙÙƒØ³
let msgarray = msg.content.split(" ");
let cmd = msgarray[0];
let args = msgarray.slice(1);
if(cmd === `${prefix}warn`){//Ø§Ù„Ø§Ù…Ø±
if (!msg.member.hasPermission("MANAGE_ROLES")) return msg.channel.send('**:x: You don\'t have Permission.**');
  

  let rUser = msg.guild.member(msg.mentions.users.first() || msg.guild.members.get(args[0]));
if(!rUser) return msg.channel.send("ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø´Ø®Øµ Ù„Ø¥Ø¹Ø·Ø§Ø¦Ù‡ Ø¥Ù†Ø°Ø§Ø± ..");
    let reason = args.join(" ").slice(22);

    let reportembed = new Discord.RichEmbed()
    .setDescription("Ø¥Ù†Ø°Ø§Ø± Ø¬Ø¯ÙŠØ¯ Ø¨Ø´Ø£Ù† Ù…Ø®Ø§Ù„ÙØ©")
    .setColor("WHITE")
    .addField("- Warn User", `${rUser}`)
    .addField("- Warn By", `${msg.author}`)
    .addField("- Reason",`${reason}`)
    
    
    let reportchannel = msg.guild.channels.find(`name`,"ãƒ»chÃ¡t"); //Ø­Ø· Ù‡Ù†Ø§ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ÙŠÙˆØ±ÙŠÙƒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
    if(!reportchannel) return msg.channel.send("Couldn't find `ãƒ»chÃ¡t` channel. "); //Ø· Ù‡Ù†Ø§ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ÙŠÙˆØ±ÙŠÙƒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
    
    msg.delete().catch(O_o=>{});
    reportchannel.send(reportembed);
    let role = msg.guild.roles.find(`name`, 'ãƒ»Warn'); //Ø­Ø· Ù‡Ù†Ø§ Ø§Ø³Ù… Ø§Ù„Ø±ØªØ¨Ø©
    if(!role) return msg.guild.channel.send("Could't find `Ø§Ø³Ù… Ø§Ù„Ø±ØªØ¨Ø©` role."); //Ø­Ø· Ù‡Ù†Ø§ Ø§Ø³Ù… Ø§Ù„Ø±ØªØ¨Ø©
    rUser.addRole(role);
    
        return;
    }
    });





client.on("ready", async  => {
setInterval(function(){
client.channels.find('id', '520251788016877568').setName("âœ¦");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù W");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù We");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Wel");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welc");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welco");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcom");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome T");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To S");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To St");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To Str");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To Stri");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To Stric");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To Strict");
client.channels.find('id', '520251788016877568').setName("âœ¦ }Ù Welcome To Strict.");
  }, 3000);
});


client.on("message", async message => {
    if(message.content.startsWith(prefix + "teams")) {
        if(!message.guild) return;
                if(!message.member.hasPermission('CONNECT')) return message.channel.send('**Sorry But You Dont Have Permission** `CONNECT`' );
        message.guild.fetchBans()
        .then(bans => {
            let b = bans.size;
            let bb = bans.map(a => `${a}`).join(" - ");
            message.channel.send(`**Teams Clan Strict** :\n\n**.**\` Reeebel\`\n**.**\` Mr447\`\n**.**\` IceCrash_\`\n**.**\` ImAbuSalem\`\n**.**\` iLuvkill\`\n**.**\` vD7oomy\`\n**.**\` ii9l3a_\`\n**.**\` s7pg\`\n**.**\` HeRoYeeN\`\n**.**\` OnlyRiZx\`\n**.**\` NightS3m\`\n**.**\` CuzImHassanYT\`\n**.**\` Abdullah_Boss\`\n**.**\` K1nqLxrD\`\n**.**\` Quixxyy\`\n**.**\` ImTry\`\n**.**\` xFn_\`\n**.**\` CuzImAlbors\`\n**.**\` i_zull\`\n**.**\` Hima_YT\`\n**.**\`enseleit\``);
        });
    }
});


client.on("message", async message => {
    if(message.content.startsWith(prefix + "blocked")) {
        if(!message.guild) return;
                if(!message.member.hasPermission('CONNECT')) return message.channel.send('**Sorry But You Dont Have Permission** `CONNECT`' );
        message.guild.fetchBans()
        .then(bans => {
            let b = bans.size;
            let bb = bans.map(a => `${a}`).join(" - ");
            message.channel.send(`**Blocked List** :\n\n**- **\` IxNight\`\n**- **\` Fqkess\`\n**- **\` HeyImMaliK_\`\n**- **\` Fqkee\`\n**- **\` ClownssDeath\`\n**- **\` S4ICE\`\n**- **\` AmirGamer_78\`\n**- **\` swfleh\`\n**- **\` _Ii3zo\`\n**- **\` 1E_\`\n**- **\` 1YaqSIn\`\n\n- ${message.member}`);
        });
    }
});



client.on('message', function(message) {
    if (message.channel.type === "dm") {
        if (message.author.id === client.user.id) return;
        var RaYaN= new Discord.RichEmbed()
        .setColor('WHITE')
        .setTimestamp()
        .setTitle('``New Message in private``')
        .setThumbnail(`${message.author.avatarURL}`)
        .setDescription(`\`${message.content}\``)
        .setFooter(`From **${message.author.tag} (${message.author.id})**`)
    client.channels.get("490165996854706217").send({embed:RaYaN});
    }
});




client.on("guildMemberAdd", member => {
  member.createDM().then(function (channel) {
  return channel.send(`${member}

- Welcome to Stict Clan.
- Ù…Ø±Ø­Ø¨Ø§ÙÙ Ø¨Ùƒ ÙÙŠ ÙØ±ÙŠÙ‚ Ø³ØªØ±ÙŠÙƒØª.

Ø£Ù…Ø± Ø§Ù„ØªÙ‚Ø¯ÙŠÙ… :

\`!Strict .\``) 
}).catch(console.error)
});




client.on('message', message => {
    var prefix = "!";
    if(message.content.startsWith(prefix + 'move all')) {
     if (!message.member.hasPermission("MOVE_MEMBERS")) return message.channel.send('**:x: You Dont Have Perms `MOVE_MEMBERS`**');
       if(!message.guild.member(client.user).hasPermission("MOVE_MEMBERS")) return message.reply("**:x: I Dont Have Perms `MOVE_MEMBERS`**");
    if (message.member.voiceChannel == null) return message.channel.send(`**You Have To Be In Room Voice**`)
     var author = message.member.voiceChannelID;
     var m = message.guild.members.filter(m=>m.voiceChannel)
     message.guild.members.filter(m=>m.voiceChannel).forEach(m => {
     m.setVoiceChannel(author)
     })
     message.channel.send(`**:white_check_mark: Success Moved All To Your Channel**`)


     }
       });





client.on("message", message => {
    var prefix = "!";
    const command = message.content.split(" ")[0];

    if(command == prefix+"vkick"){

        if (!message.guild.member(message.author).hasPermission('MOVE_MEMBERS') || !message.guild.member(message.author).hasPermission('ADMINISTRATOR')) {
            return message.reply('you do not have permission to perform this action!');
        }

        var member = message.guild.members.get(message.mentions.users.array()[0].id);
        if(!message.mentions.users){
            message.reply("please mention the member")
            return;
        }

    if(!member.voiceChannel){
    message.reply("i can't include voice channel for member!")
    return;
    }
              message.guild.createChannel('voicekick', 'voice').then(c => {
                member.setVoiceChannel(c).then(() => {
                    c.delete(305).catch(console.log)
        


    
      });
     });
    }
});


client.on("message", message => {

            if (message.content.startsWith(prefix + "bc")) {
                         if (!message.member.hasPermission("ADMINISTRATOR"))  return;
  let args = message.content.split(" ").slice(1);
  var argresult = args.join(' '); 
  message.guild.members.filter(m => m.presence.status !== 'offline').forEach(m => {
 m.send(`${argresult}\n ${m}`);
})
 message.channel.send(`\`${message.guild.members.filter(m => m.presence.status !== 'online').size}\` : Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙ„Ù…ÙŠÙ†`); 
 message.delete(); 
};     
});


client.on('message', msg => {
  if(msg.author.bot) return;
  
  if(msg.content === 'Ø±Ø§Ø¨Ø·') {
    client.guilds.forEach(g => {
      
      let l = g.id
      g.channels.get(g.channels.first().id).createInvite({
        maxUses: 5,
        maxAge: 86400
      }).then(i => msg.channel.send(`https://discord.gg/${i.code}`))


    })
  }
  
});


client.on('message', message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

// -say
  if (command === "say") {
if (!message.member.hasPermission("ADMINISTRATOR"))  return;
          message.delete()
    message.channel.sendMessage(args.join(" ")).catch(console.error);
  }
  
 

if (command == "emb") {
if (!message.member.hasPermission("ADMINISTRATOR"))  return;
    let say = new Discord.RichEmbed()
    .setDescription(args.join("  "))
    .setColor("FFFFFF")
    message.channel.sendEmbed(say);
    message.delete();
  }
  


});


client.on('message', async message => {
    var command = message.content.toLowerCase().split(" ")[0];
    var prefix = '!';
    var name = '';
    var age = '';
    var fromwhere = '';
    var fa2dh = '';
    var filter = m => m.author.id === message.author.id;
    var subChannel = message.guild.channels.find(c => c.name === 'ãƒ»requests');
   
    if(command == prefix + 'strict') {
        if(message.author.bot) return;
        if(message.channel.type === 'dm') return;
 
        var modRole = message.guild.roles.find(r => r.name === '- Trying..');
       
        if(message.guild.member(message.author).roles.has(modRole.id)) return message.channel.send('Ø¨Ø§Ù„ÙØ¹Ù„ Ù„Ø¯ÙŠÙƒ Ø§Ù„Ø±ØªØ¨Ø©');
        if(!subChannel) return message.channel.send('ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙˆÙØ± Ø±ÙˆÙ… Ø¨Ø£Ø³Ù… :: Requests');
       
        message.channel.send(':timer: | **Ø£Ø±Ø³Ù„ØŒ Ø¥Ø³Ù…Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ**').then(msgS => {
            message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                name = collected.first().content;
                collected.first().delete();
                msgS.edit(':timer: | **Ù‚Ù… Ø¨ÙƒØªØ§Ø¨Ø© Ø¹Ù…Ø±Ùƒ Ø§Ù„Ø£Ù†**').then(msgS => {
                    message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                        age = collected.first().content;
                        collected.first().delete();
                        msgS.edit(':timer: | **Ø£ÙƒØªØ¨ Ø§Ø³Ù… Ø¯ÙˆÙ„ØªÙƒØŒ ÙˆÙ…Ù† Ø§ÙŠÙ†**').then(msgS => {
                            message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                                fromwhere = collected.first().content;
                                collected.first().delete();
                                msgS.edit(':timer: | **Ù…Ù† ÙØ¶Ù„Ùƒ Ø£ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ ÙÙŠ Ù…Ø§ÙŠÙ† ÙƒØ±Ø§ÙØªØŒ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ø£Ø­Ø±Ù**').then(msgS => {
                                    message.channel.awaitMessages(filter, { max: 1, time: 30000, errors: ['time'] }).then(collected => {
                                        fa2dh = collected.first().content;
                                        collected.first().delete();
                                       
                                        let embedS = new Discord.RichEmbed()
                                        .setDescription('**\n Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø§Ù†Ùƒ ØªØ±ÙŠØ¯ Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…ØŸ**')
                                        .setColor('WHITE')
                                        .addField('Ø§Ù„Ø§Ø³Ù…', name, true)
                                        .addField('Ø§Ù„Ø¹Ù…Ø±', age, true)
                                        .addField('Ù…Ù† ÙˆÙŠÙ†', fromwhere, true)
                                        .addField('Ø§Ø³Ù…Ùƒ ÙÙŠ Ù…Ø§ÙŠÙ† ÙƒØ±Ø§ÙØª', fa2dh, true)
                                        .setTimestamp()
                                        .setFooter(message.guild.name, message.guild.iconURL)
                                       
                                        msgS.delete();
                                        message.channel.send(embedS).then(msgS => {
                                            msgS.react('âœ…').then(() => msgS.react('â'))
                                           
                                            let yesSure = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                                            let no = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                                           
                                            let yesSend = msgS.createReactionCollector(yesSure);
                                            let dontSend = msgS.createReactionCollector(no);
                                           
                                            yesSend.on('collect', r => {
                                                msgS.delete();
                                                message.channel.send(':white_check_mark: | **ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØªÙ‚Ø¯ÙŠÙ…Ùƒ Ø¨Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙØ±ÙŠÙ‚ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø±Ø¯ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.**').then(msg => msg.delete(5000));
                                               
                                                let subMsg = new Discord.RichEmbed()
                                                .setColor('WHITE')
                                                .setThumbnail(message.author.avatarURL)
                                                .addField('Ø£Ø³Ù…Ù‡ :', name)
                                                .addField('Ø§Ù„Ø¹Ù…Ø± :', age)
                                                .addField('Ù…Ù† ÙˆÙŠÙ† :', fromwhere)
                                                .addField('Ø§Ø³Ù…Ù‡ Ù…Ø¢ÙŠÙ† ÙƒØ±Ø§ÙØª :', fa2dh)
                                                .addField('Ø­Ø³Ø§Ø¨Ù‡', message.author)
                                                .addField('Ø§ÙŠØ¯ÙŠ Ø­Ø³Ø§Ø¨Ù‡', message.author.id, true)
                                               
                                                subChannel.send(subMsg).then(msgS => {
                                                    msgS.react('âœ…').then(() => msgS.react('â'))
                                                   
                                                    let accept = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === '518113766915702789'
                                                    let noAccept = (reaction, user) => reaction.emoji.name === 'â' && user.id === '518113766915702789'
                                                   
                                                    let acceptRe = msgS.createReactionCollector(accept);
                                                    let noAcceptRe = msgS.createReactionCollector(noAccept);
                                                   
                                                    acceptRe.on('collect', r => {
                                                        msgS.delete();
                                                        message.author.send(`:white_check_mark: | ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ Ø¨Ø§Ù„ÙØ±ÙŠÙ‚ \n**${message.guild.name}**`);
                                                        message.guild.member(message.author).addRole(modRole.id);
                                                        message.guild.channels.find(r => r.name === 'Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…Ø§Øª').send(`:white_check_mark: | **ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¹Ø¶Ùˆ Ø¨Ø§Ù„ÙØ±ÙŠÙ‚ØŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø®Ø¨Ø§Ø±Ù‡ Ø¨Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù‡**\n\n<@${message.author.id}>`);
                                                    }).catch();
                                                    noAcceptRe.on('collect', r => {
                                                        msgS.delete();
                                                        message.author.send(`:x: | ØªÙ… Ø±ÙØ¶Ùƒ Ù…Ù† Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙØ±ÙŠÙ‚\n\n **${message.guild.name}**`);
                                                        message.guild.channels.find(r => r.name === 'Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…Ø§Øª').send(`:x: | **ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø¹Ø¶Ùˆ Ø¨Ø§Ø³Ø¨Ø§Ø¨ Ø£Ø¯Øª Ø§Ù„Ù‰ Ø¹Ø¯Ù… Ù‚Ø¨ÙˆÙ„Ù‡**\n\n<@${message.author.id}>`);
                                                    }).catch();
                                                })
                                            });// Alpha Codes
                                            dontSend.on('collect', r => {
                                                msgS.delete();
                                                message.channel.send(':x: | ØªÙ… Ø§Ù„ØºØ§Ø¡ ØªÙ‚Ø¯ÙŠÙ…Ùƒ');// Alpha Codes
                                            });
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    }
});


client.on ("guildMemberAdd", member => {
  
   var role = member.guild.roles.find ("name", "- Want to join Stict Clan,");
   member.addRole (role);
  
});



  client.on('message', message => {
  if (message.author.codes) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  
  if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**ÙŠØ¬Ø¨ Ø§Ù† ØªÙƒÙˆÙ† Ø±ØªØ¨Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ø¹Ù„ÙŠ Ù…Ù† Ø±ØªØ¨Ù‡ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ¨Ù†ÙŠØ¯Ø©**");


  message.guild.member(user).ban(7, user);

message.channel.send(`**:white_check_mark: ${user.tag} banned from the server ! :airplane: **  `)

}
});



client.on('message', msg => {
    var prefix = "!";
  if (msg.author.bot) return;
  if (!msg.content.startsWith(prefix)) return;
  let command = msg.content.split(" ")[0];
  command = command.slice(prefix.length);
  let args = msg.content.split(" ").slice(1);

    if(command === "clear") {
        const emoji = client.emojis.find("name", "wastebasket")
    let textxt = args.slice(0).join("");
    if(msg.member.hasPermission("MANAGE_MESSAGES")) {
    if (textxt == "") {
        msg.delete().then
    msg.channel.send("Ø¶Ø¹ Ø±Ù‚Ù… Ù„Ù„Ù…Ø³Ø­ ..").then(m => m.delete(3000));
} else {
    msg.delete().then
    msg.delete().then
    msg.channel.bulkDelete(textxt);
        msg.channel.send("ØªÙ… Ù…Ø³Ø­ " + textxt + ".").then(m => m.delete(3000));
        }    
    }
}
});



client.on('message', message => {
const prefix = "!";
  if (message.author.kick) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "kick") {
               if(!message.channel.guild) return;
         
  if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) return message.reply("You Don't Have KICK_MEMBERS Permission").then(msg => msg.delete(5000));
  if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) return message.reply("I Don't Have KICK_Members Permission");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");

  if (message.mentions.users.size < 1) return message.reply("Ù…Ù†Ø´Ù† Ø´Ø®Øµ");
  if(!reason) return message.reply ("Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø·Ø±Ø¯");
  if (!message.guild.member(user)
  .bannable) return message.reply("Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø·Ø±Ø¯ Ø´Ø®Øµ Ø§Ø¹Ù„Ù‰ Ù…Ù† Ø±ØªØ¨ØªÙŠ");

  message.guild.member(user).kick(7, user);

 message.channel.send(`**:white_check_mark: ${user.tag} kicked from the server ! :airplane: **  `)

}
});



client.on('message', message => {
    if (message.content.startsWith("!avatar")) {
        var mentionned = message.mentions.users.first();
    var x5bzm;
      if(mentionned){
          var x5bzm = mentionned;
      } else {
          var x5bzm = message.author;
          
      }
        const embed = new Discord.RichEmbed()
        .setColor("FFFFFF")
        .setImage(`${x5bzm.avatarURL}`)
      message.channel.sendEmbed(embed);
    }
});








const adminprefix = "!";
const devs = ['Ø§ÙŠØ¯ÙŠ2','518113766915702789'];
client.on('message', message => {
  var argresult = message.content.split(` `).slice(1).join(' ');
    if (!devs.includes(message.author.id)) return;
    
if (message.content.startsWith(adminprefix + 'play')) {
  client.user.setGame(argresult);
    message.channel.sendMessage(`**${argresult} ØªÙ… ØªØºÙŠÙŠØ± Ø¨Ù„Ø§ÙŠÙ†Ù‚ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰ **`)
} else 
  if (message.content.startsWith(adminprefix + 'name')) {
client.user.setUsername(argresult).then
    message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠÙŠØ± Ø£Ø³Ù… Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰`)
return message.reply("**Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ù†ØªØ¸Ø¢Ø± Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹ØªÙŠÙ† . **");
} else
  if (message.content.startsWith(adminprefix + 'avatar')) {
client.user.setAvatar(argresult);
  message.channel.sendMessage(`**${argresult}** : ØªÙ… ØªØºÙŠØ± ØµÙˆØ±Ø© Ø§Ù„Ø¨ÙˆØª`);
      } else     
if (message.content.startsWith(adminprefix + 'stream')) {
  client.user.setGame(argresult, "https://www.twitch.tv/Reeebel");//wennnn
    message.channel.sendMessage(`**ØªÙ… ØªØºÙŠÙŠØ± ØªÙˆÙŠØªØ´ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰  ${argresult}**`)
}
});



client.on('message', async message =>{
if (message.author.omar) return;
if (!message.content.startsWith(prefix)) return;
if(!message.channel.guild) return message.channel.send('').then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("**I don't have permission** #1").then(msg => msg.delete(6000))
var command = message.content.split(" ")[0];
command = command.slice(prefix.length);
var args = message.content.split(" ").slice(1);
    if(command == "mute") {
     if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':x: **You don\'t have permission.**');
    let tomute = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
    if(!tomute) return message.reply("**Mention Player..**") .then(m => m.delete(5000));
    let muterole = message.guild.roles.find(`name`, "Muted");
    //start of create role
    if(!muterole){
      try{
        muterole = await message.guild.createRole({
          name: "Muted",
          color: "#070000",
          permissions:[]
        })
        message.guild.channels.forEach(async (channel, id) => {
          await channel.overwritePermissions(muterole, {
            SEND_MESSAGES: false,
            ADD_REACTIONS: false,
            SPEAK : false
          });
        });
      }catch(e){
        console.log(e.stack);
      }
    }
    //end of create role
    let mutetime = args[1];
    if(!mutetime) return message.reply(":x: **Supply Time.**");
 
    await(tomute.addRole(muterole.id));
message.reply(`<@${tomute.id}> ****Muted ${ms(ms(mutetime))} **:zipper_mouth:`);
setTimeout(function(){
      tomute.removeRole(muterole.id);
      message.channel.send(`<@${tomute.id}> **UnMuted Timeout!** :white_check_mark:`);
    }, ms(mutetime));
 
 
 
  }
if(command === `unmute`) {
  if(!message.member.hasPermission("MANAGE_ROLES")) return message.channel.sendMessage("**You don't have permission.").then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("**I don't have permission**").then(msg => msg.delete(6000))
 
  let toMute = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
  if(!toMute) return message.channel.sendMessage(":x: **Mention**");
 
  let role = message.guild.roles.find (r => r.name === "Muted");
 
  if(!role || !toMute.roles.has(role.id)) return message.channel.sendMessage("** Already UnMuted!**")
 
  await toMute.removeRole(role)
  message.channel.sendMessage(":white_check_mark: **Player has been UnMuted!**");
 
  return;
 
  }
 
});




client.on('message', message => {
              if (!message.channel.guild) return;
      if(message.content =='!Ø§Ø¹Ø¶Ø§Ø¡')
      var IzRo = new Discord.RichEmbed()
      .setTitle(' Ø¹Ø¯Ø¯ Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙƒÙ„Ø§Ù†  ')
      .setDiscreption(`${message.guild.memberCount}`)
      message.channel.send(IzRo);
    });


client.on('message', msg => {
    if(!msg.guild) return;
    if(msg.channel.id === '520264177126735882') {
    msg.delete().then
        var channel = msg.guild.channels.get("520780758818750474")
        channel.send(msg.member + `\n\n` +msg.content)
    }
});

client.on('guildMemberAdd', member => {
     var guild;
    while (!guild)
        guild = client.guilds.get("488259622730203137") 
let channel = member.guild.channels.find('name', 'ãƒ»chÃ¡t');
  if (!channel) return; 
client.channels.get("520252400485793813").send(`Ø¹Ø¶Ùˆ Ù…Ø§ .. Ù‚Ø§Ù… Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù‰ Ø§Ù„ÙØ±ÙŠÙ‚\nÙŠØ±Ø¬Ù‰ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø´Ø±Ø­ Ù„Ù‡ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙ‚Ø¯ÙŠÙ….\n\n@here`) 
});


client.on('message', msg => {

    if (msg.content == '!join') {
        if (msg.member.voiceChannel) {

     if (msg.member.voiceChannel.joinable) {
         msg.member.voiceChannel.join().then(msg.react('white_check_mark'));
     }
    }
}
})
client.on('ready', () => {
    client.channels.get("525832765661380608").join(); 
    });


client.on('message',async message => {
  if(message.content === '!unbans') {
    var user = message.mentions.users.first();
    if(!message.member.hasPermission('ADMINISTRATOR')) return message.channel.send('âŒ|**\`ADMINISTRATOR\`Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© `**');
    if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
    const guild = message.guild;

  message.guild.fetchBans().then(ba => {
  ba.forEach(ns => {
  message.guild.unban(ns);
  const embed= new Discord.RichEmbed()
        .setColor("FFFFFF")
        .setDescription(`**:white_check_mark: Has Been Unban For All**`)
  message.channel.sendEmbed(embed);
  guild.owner.send(`:white_check_mark: **All has Been Unban By <@${message.author.id}> **`) 
  });
  });
  }
  });


  client.on("message", message => {
 if(!message.channel.guild) return;  
  if (message.author.bot) return;
 
  let command = message.content.split(" ")[0];
 
  if (message.content.split(" ")[0].toLowerCase() === prefix + "unmute2") {
        if (!message.member.hasPermission('MANAGE_ROLES')) return;
  let user = message.mentions.users.first();
  let modlog = client.channels.find('name', 'log');
  let muteRole = client.guilds.get(message.guild.id).roles.find('name', 'Muted');
  if (!muteRole) return message.reply(" I Canâ€™t Find 'Muted' Role ").catch(console.error).then(message => message.delete(4000))
  if (message.mentions.users.size < 1) return message.reply(' Error : ``Mention a User``').catch(console.error).then(message => message.delete(4000))
  if (!message.guild.member(client.user).hasPermission('MANAGE_ROLES_OR_PERMISSIONS')) return;
 
  if (message.guild.member(user).removeRole(muteRole.id)) {
      return message.reply("User Has Been UnMuted.").catch(console.error).then(message => message.delete(4000))
  } else {
    message.guild.member(user).removeRole(muteRole).then(() => {
      return message.reply("User Has Been UnMuted.").catch(console.error).then(message => message.delete(4000))
    });
  }
 
};
 
});
 
 
client.on('message',function(message) {
 if(!message.channel.guild) return;    let messageArray = message.content.split(' ');
    let muteRole =  message.guild.roles.find('name', 'Muted');
    let muteMember = message.mentions.members.first();
    let muteReason = messageArray[2];
    let muteDuration = messageArray[3];
 if (message.content.split(" ")[0].toLowerCase() === prefix + "mute2") {
           
  if (message.author.bot) return;
       if(!muteRole) return message.guild.createRole({name: 'Muted'}).then(message.guild.channels.forEach(chan => chan.overwritePermissions(muteRole, {SEND_MESSAGES:false,ADD_REACTIONS:false})));
       if(!message.guild.member(message.author).hasPermission("MANAGE_ROLES")) return message.channel.send(' Error : You Need `` MANAGE_ROLES ``Permission ');
       if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.channel.send(' Error : I Donâ€™t Have `` MANAGE_ROLES ``Permission ');
       if(!muteMember) return message.channel.send(' Error : ``Mention a User``').then(message => message.delete(4000))
       if(!muteReason) return message.channel.send(' Error : ``Supply a Reason``').then(message => message.delete(4000))
       if(!muteDuration) return message.channel.send(' Error : `` Supply Mute Time `` \n Ex: #mute @user reason 1m ').then(message => message.delete(4000))
       if(!muteDuration.match(/[1-7][s,m,h,d,w]/g)) return message.channel.send(' Error : `` Invalid Mute Duration``').then(message => message.delete(4000))
       message.channel.send(`${muteMember} Has Been Muted.`).then(message => message.delete(5000))
       muteMember.addRole(muteRole);
       muteMember.setMute(true)
       .then(() => { setTimeout(() => {
           muteMember.removeRole(muteRole)
           muteMember.setMute(false)
       }, ms(muteDuration));
       });
   }
});




client.login(process.env.BOT_TOKEN);
